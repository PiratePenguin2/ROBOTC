#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, dgtl9)
#pragma config(Motor,  port2,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight, encoderPort, dgtl11)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int tol = 5;
const int encoderTicks = 360;

const int wheelDiam = 4;
const int wheelWidth = 12;

//const float motorMax = 127;
const float motorHigh = 75;	//75
const float motorLow = 50;	//50

const float motorTurnHigh = 55;
const float motorTurnLow = 50;

const float motorStop = 0;

const float speedSmoothing = 0.001;	//0.001

//float targetSpeedL = 0.0;
//float targetSpeedR = 0.0;
float smoothSpeedL = 0.0;
float smoothSpeedR = 0.0;


float lerp(float a, float b, float weight)
{
	return a * (1 - weight) + b*weight;
}

	void zero()
	{
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		smoothSpeedL = 0;
		smoothSpeedR = 0;
	}



void moveForward(int distance)
{
	int ticks = (distance / (wheelDiam * PI)) * (encoderTicks);

  while(SensorValue[leftEncoder] < ticks || SensorValue[rightEncoder] < ticks)
  {
		//Left Motor
  	if (SensorValue[leftEncoder] < ticks)
		{
			if (SensorValue[rightEncoder] - SensorValue[leftEncoder] > tol)  // While less than 5 rotations on the leftEncoder...
			{
				motor[leftMotor] = motorHigh;
			}
			else
			{
				smoothSpeedL = lerp(smoothSpeedL, motorLow, speedSmoothing);
				motor[leftMotor] = smoothSpeedL;
			}
		}
		else
		{
				smoothSpeedL = lerp(smoothSpeedL, motorStop, speedSmoothing);
				motor[leftMotor] = smoothSpeedL;
		}

		//Right Motor
		if (SensorValue[rightEncoder] < ticks)
		{
			if (SensorValue[leftEncoder] - SensorValue[rightEncoder] > tol)  // While less than 5 rotations on the rightEncoder...
			{
				motor[rightMotor] = motorHigh;
			}
			else
			{
				smoothSpeedR = lerp(smoothSpeedR, motorLow, speedSmoothing);
				motor[rightMotor] = smoothSpeedR;
			}
		}
		else
		{
				smoothSpeedR = lerp(smoothSpeedR, motorStop, speedSmoothing);
				motor[rightMotor] = smoothSpeedR;
		}
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	wait1Msec(1000);
}

void moveBackward(int distance)
{
	int ticks = (distance / (wheelDiam * PI)) * (encoderTicks);

  while(SensorValue[leftEncoder] > ticks || SensorValue[rightEncoder] > ticks)
  {
		//Left Motor
  	if (SensorValue[leftEncoder] > ticks)
		{
			if (SensorValue[leftEncoder] - SensorValue[rightEncoder] > tol)  // While less than 5 rotations on the leftEncoder...
			{
				motor[leftMotor] = -motorHigh;
			}
			else
			{
				smoothSpeedL = lerp(smoothSpeedL, -motorLow, speedSmoothing);
				motor[leftMotor] = smoothSpeedL;
			}
		}
		else
		{
				smoothSpeedL = lerp(smoothSpeedL, -motorStop, speedSmoothing);
				motor[leftMotor] = smoothSpeedL;
		}

		//Right Motor
		if (SensorValue[rightEncoder] > ticks)
		{
			if (SensorValue[rightEncoder] - SensorValue[leftEncoder] > tol)  // While less than 5 rotations on the leftEncoder...
			{
				motor[rightMotor] = -motorHigh;
			}
			else
			{
				smoothSpeedR = lerp(smoothSpeedR, -motorLow, speedSmoothing);
				motor[rightMotor] = smoothSpeedR;
			}
		}
		else
		{
				smoothSpeedR = lerp(smoothSpeedR, motorStop, speedSmoothing);
				motor[rightMotor] = smoothSpeedR;
		}
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	wait1Msec(1000);
}


//pointTurn			//(r +- offset/2) * (deg/360) * (1/(wheelDiam * PI)) * 360
void pointTurn(float deg, float offset)
{
	int Lticks  = (int)( ((offset + wheelWidth/1) * PI) * (deg/360) * (1/(wheelDiam * PI)) * 360 );//((deg/2) / (wheelDiam * PI)) * (encoderTicks);
	int Rticks  = (int)( ((offset - wheelWidth/1) * PI) * (deg/360) * (1/(wheelDiam * PI)) * 360 );

		while(abs(SensorValue[leftEncoder]) < abs(Lticks) || abs(SensorValue[rightEncoder]) < abs(Rticks))
	  {
			//Left Motor
	  	if (abs(SensorValue[leftEncoder]) < abs(Lticks))
			{
				if (abs(SensorValue[leftEncoder]) - abs(SensorValue[rightEncoder]) > 10)//dir ? (abs(SensorValue[rightEncoder]) - abs(SensorValue[leftEncoder] > tol)) : (SensorValue[rightEncoder] + SensorValue[leftEncoder] < -tol) )  // While less than 5 rotations on the leftEncoder...
				{
					smoothSpeedL = lerp(smoothSpeedL, (Lticks > 0 ? motorTurnHigh : -motorTurnHigh), 1);
					motor[leftMotor] = smoothSpeedL;
				}
				else
				{
					smoothSpeedL = lerp(smoothSpeedL, (Lticks > 0 ? motorTurnLow : -motorTurnLow), speedSmoothing);
					motor[leftMotor] = smoothSpeedL;
				}
			}
			else
			{
					smoothSpeedL = lerp(smoothSpeedL, motorStop, 1);
					motor[leftMotor] = smoothSpeedL;
			}

			//Right Motor
			if (abs(SensorValue[rightEncoder]) < abs(Rticks))
			{
				if (abs(SensorValue[rightEncoder]) - abs(SensorValue[leftMotor]) > 10)  // While less than 5 rotations on the leftEncoder...
				{
					smoothSpeedR = lerp(smoothSpeedR, (Rticks > 0 ? motorTurnHigh : -motorTurnHigh), 1);
					motor[rightMotor] = smoothSpeedR;
				}
				else
				{
					smoothSpeedR = lerp(smoothSpeedR, (Rticks > 0 ? motorTurnLow : -motorTurnLow), speedSmoothing);
					motor[rightMotor] = smoothSpeedR;
				}
			}
			else
			{
					smoothSpeedR = lerp(smoothSpeedR, motorStop, 1);
					motor[rightMotor] = smoothSpeedR;
			}
		}
		motor[leftMotor] = 0;
		motor[rightMotor] = 0;
		smoothSpeedL = 0;
		smoothSpeedR = 0;
		wait1Msec(1000);
	//}
}




task main()
{
	//for (int i = 0; i < 1; i++)
	while (true)
	{
		motor[leftMotor] = vexRT[Ch2];
		motor[rightMotor] = vexRT[Ch3];

		if (vexRT[Btn8U] == 1)
		{
			zero();
		  //moveForward(9 + (4 * 24));
		  //moveBackward(0);

		  pointTurn(360, 0);	//Change bool to string of RIGHT or LEFT



			/*
			if (false)
			{

				//swingTurn("RIGHT", 90);
				moveForward(9 + (1 * 24));
		  	moveBackward(0);
		  }
			*/

		}
	}
}


		  /*


		  moveForward(9 + (2 * 24));
		  	moveBackward(9);

		  moveForward(9 + (3 * 24));
		  	moveBackward(9);

		  moveForward(9 + (4 * 24));
		  	moveBackward(0);*/
