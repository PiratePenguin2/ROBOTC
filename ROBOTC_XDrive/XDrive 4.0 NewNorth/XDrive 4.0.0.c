#pragma config(Motor,  port3,           North_drive,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           East_drive,    tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           South_drive,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           West_drive,    tmotorVex393TurboSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

NewNorth = (SensorValue[Gyro1]);
		// New North is where the robot belives north is.

		// use the log drive to ease the driving but still keep the 127 max
		x_joy= log_drive(vexRT[Ch4]);
		y_joy= log_drive(vexRT[Ch3]);
		rotatey_joy= log_drive(vexRT[Ch2]);
		rotatex_joy= log_drive(vexRT[Ch1]);


		//The 8UP button resets the gyro so the
		//current heading is considered forward.
		//This is helpful because we can reset North if we change our position.
		if (vexRT[Btn7U] == 1) {
			SensorValue[Gyro1] = 0;
			NewNorth = 0;
		}

		direction_vector= sqrt((x_joy*x_joy)+(y_joy*y_joy));
		if(y_joy!=0 && y_joy>0)
		{
			direction_angle = 10*radiansToDegrees(atan((float)x_joy/(float)y_joy));
		}
		else if(y_joy !=0 && y_joy< 0)
		{

			direction_angle = 10*radiansToDegrees(atan((float)(x_joy*-1)/(float)(y_joy*-1))+1800);
			//writeDebugStreamLine("special x_joy: %d y_joy %d  dir ang %f", x_joy, y_joy, direction_angle);
		}
		else
		{
			if(x_joy==0)direction_angle = 0;
			if(x_joy<0)direction_angle = 1800;
		}
		/*writeDebugStreamLine("x_joy: %d y_joy %d ", x_joy, y_joy);
		writeDebugStreamLine("direction_angle: %f ", direction_angle);
		writeDebugStreamLine("direction_vector: %d ", direction_vector);*/

		cosX = cosDegrees(NewNorth/10);
		sinY = sinDegrees(NewNorth/10);
		/*writeDebugStreamLine("gyro: %f ", NewNorth/10);
		writeDebugStreamLine("cos gyro: %f \n", cosX);
		writeDebugStreamLine("sin gyro: %f \n", sinY);*/


		drive_drift = (direction_angle - NewNorth)/10;  // divie by 10 since the angles are in gyro *10 range

		cosX = cosDegrees(drive_drift);
		sinY = sinDegrees(drive_drift);
		driveX = direction_vector * cosX;
		driveY = direction_vector * sinY;

		rotation = rotatex_joy;


		motorReq[East_drive]= limitMotor((driveX) + rotation);
		motorReq[West_drive] = limitMotor((driveX*-1) + rotation);
		motorReq[North_drive] = limitMotor((driveY*-1) + rotation);
		motorReq[South_drive] = limitMotor((driveY) + rotation);
