#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  eStopBtn,       sensorDigitalIn)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           rearMotor,     tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, dgtl5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use car-style steering, where the right Y-axis		*|
|*	joystick controls the bot moving forward and backwards, and the			*|
|*	right X-axis joystick controls steering byslowing down the left or	*|
|*	right wheels respectively. The rear wheel is equal to the difference*|
|*	between the right and left motors, to help the bot pivot and remain	*|
|*	stable.																															*|
\*----------------------------------------------------------------------*/

/*-----Config-----*/
	const float rearMultiplier = 0.35; //This multiplier is used for the back wheel, to ensure that it is pivoting at a similar speed to the outside wheels.
	const float jitter = 25.0;
	const float motorMax = 127; // # out of 127
	const float motorMin = 10.0;

	const float speedSmoothing = .25; //0<x<1, closer to zero = smoother
		//const string leftRightCh = "Ch3";	//Ch3 is single joystick, only using left joystick. Ch1 is double joystick, with forward/backwards as left joystick and left/right as right joystick

//Variables
	float targetSpeedL = 0.0;
	float targetSpeedR = 0.0;

	float smoothSpeedL = 0.0;
	float smoothSpeedR = 0.0;

	bool eStopState = true;
	float fps = 8;

/*-----enableCheck-----*/
	void enableCheck()
	{
		if	(								//If all conditions met to enable
			vexRT(Btn5U) && vexRT(Btn6U)	//If 5U and 6U pressed
		//&&	!SensorValue(eStopBtn)
			)
		{
			eStopState = false;	//turn off eStop
			//return true;		//initiate startup
		}
		//return false;			//otherwise, keep eStop off
	}

/*-----eStopCheck-----*/
	void eStopCheck()
	{
		if	(									//If eStop has reason to be turned on
			vexRT(Btn5D)	||	vexRT(Btn6D)	//If 5D or 6D
		||	(SensorValue(eStopBtn) == 0)
			)
		{
			eStopState = true;	//turn on eStop
			//return true;		//initiate shutdown
		}
		//return false;			//otherwise, keep running
	}

/*-----startup-----*/
	void startup()
	{
		fps = 20;
	}

/*-----shutdown-----*/
	void shutdown()
	{
		motor[leftMotor] = 0;
		motor[rearMotor] = 0;
		motor[rightMotor] = 0;

		targetSpeedL = 0;
		targetSpeedR = 0;
		smoothSpeedL = 0;
		smoothSpeedR = 0;

		fps = 4;
	}

/*--Linear interpolation (smooth acceleration) function--*/
	float lerp(float a, float b, float weight)
	{
		//Linear interpolation formula: x = a(1-t) + bt
		return a*(1 - weight) + b*weight;
	}

/*-----DriftDrive-----*/
	void driftDriveTank()
	{
	//Lx is Ch1, Ly is Ch2, Ry is Ch3, Rx is Ch4
  	  //If Lx [Ch4] is right, slow down right motor. If it's left, slow down left motor

/*Take inputs from the joystick, and determine how the bot should move*/
	//Left
	if (abs(vexRT[Ch3]) > jitter)
	{
		targetSpeedL = vexRT[Ch3] * motorMax / 127;
	}
	else
	{
		targetSpeedL = 0;
	}
	
	//Right
	if (abs(vexRT[Ch2]) > jitter)
	{
		targetSpeedR = vexRT[Ch2] * motorMax / 127;
	}
	else
	{
		targetSpeedR = 0;
	}

/*Smooth the speed to prevent motor damage*/
		smoothSpeedL = lerp(smoothSpeedL, targetSpeedL, speedSmoothing);			//lerp(smoothSpeedL, targetSpeedL, accel * (delta));
		smoothSpeedR = lerp(smoothSpeedR, targetSpeedR, speedSmoothing);			//lerp(smoothSpeedR, targetSpeedR, accel * (delta));


/*Write the new speeds to the Left, Right, and Rear motors*/
		if( abs(smoothSpeedL) > motorMin)
		{
			motor[leftMotor] = smoothSpeedL;
		}
		else motor[leftMotor] = 0.0;
		if (abs(smoothSpeedR) > motorMin)
		{
			motor[rightMotor] = smoothSpeedR;
		}
		else motor[rightMotor] = 0.0;
		motor(rearMotor) = (smoothSpeedL - smoothSpeedR) * rearMultiplier;	//The rear motor is used to help with pivoting, given by the difference between the left and right inputs

	}

/*-----Task Main-----*/
task main()
{
	shutdown();	//Initiate Shutdown
	while(true)	//Always
	{
		enableCheck();
		if (!eStopState)	//if eStop off, initiate startup
		{
			startup();	//Initiate Startup

			while (!eStopState)	//While eStop is off
			{

				driftDriveTank();

				wait1Msec(1000/fps);
				eStopCheck();
			}	//Main Enabled

			shutdown();	//Initiate Shutdown

		}	//Check

		wait1Msec(1000/fps);

	}	//Always Run
}	//Task Main
		// robot :)
		// -approved by the Club Secretary of War
