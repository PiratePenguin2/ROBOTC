#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use tank-style steering, where		*|
|*	the left and right joysticks control the left or right wheels on		*|
|*	the bot.
\*----------------------------------------------------------------------*/

//----------Config----------
	const float jitter = 10;

	void controllerInput(short channel, short directionID);		//[Base] Updates "ideal" positions based on the controller inputs using vector addition
	void botTargetPivotFn();



//----------Inputs----------
/* The inputs from the controller */
	//float Lx_controllerInput;
	//float Ly_controllerInput;

	float Rx_controllerInput;
	float Ry_controllerInput;



//----------Ideal Speeds----------
/* The ideal direction and speed of the entire bot */
	float botTarget_pivot = 0.0; //For all "pivot", in Degrees
	float botTarget_drive = 0.0; //For all "drive", meters per second or percent speed?? "+" is drive forward (most likely), "-" is drive backwards


/* The ideal directions and speeds of each wheel assembly */
	float LTarget_drive = 0.0;
	float RTarget_drive = 0.0;

	float LSmooth_drive = 0.0;
	float RSmooth_drive = 0.0;
	float rearSmooth_drive = 0.0;


/* The rotation the bot and each pivot should physically be at (using encoders)*/


	//int botPos_pivot = 0.0; 	//maybe add an encoder or use existing encoder that understands where pivots start at
	//int bot = 0.0;








task main()
{
	while(1==1){
			//Lx is Ch1, Ly is Ch2, Ry is Ch3, Rx is Ch4
			//vexRT[Ch1]


	/* [Base] Update "ideal" positions based on the controller inputs using vector addition */
		//drive
		controllerInput(Ch4,Rx_controllerInput);
		controllerInput(Ch3,Ry_controllerInput);

		//writeDebugStreamLine("%c", Rx_controllerInput);
		//writeDebugStreamLine("%c", Ry_controllerInput);
		botTarget_drive = sqrt( (Rx_controllerInput^2)+(Ry_controllerInput^2) );		//a^2 + b^2 = c^2




		botTargetPivotFn();


		/* [Base] Understand how the bot has moved since the last tick and update the smooth path to an existing or new ideal*/




		/* [All] Execute new instructions to motors */
//		motor(leftPivot) = Lpos_pivot;
//		motor(leftDrive) = Rpos_drive;

//		motor(frontPivot) = Fpos_pivot;
//		motor(frontDrive) = Fpos_drive;

//		motor(rightPivot) = Lpos_pivot;
//		motor(rightDrive) = Rpos_drive;

	}
}



/*****************FUNCTIONS********************************/
void controllerInput(short channel, short directionID)
{
	if ((vexRT[channel] < jitter) && (vexRT[channel] > -jitter))			//Rx
		{
			directionID = 0;

		}
		else
		{
			directionID = abs(vexRT[channel]);
		}
}



void botTargetPivotFn()
{
	if ((Lx_controllerInput >= 0) && (Ly_controllerInput <= 90))
		{
			//0 to 90
		}
		else if ((Lx_controllerInput > 90) && (Ly_controllerInput <= 180))
		{
			//90.1 to 180
		}
		else if ((Lx_controllerInput < 0) && (Ly_controllerInput >= -90))
		{
			//-0.1 to -90
		}
		else
		{
			//-90.1 to -179.9
		}
}





















		/*if ((vexRT[Ch4] < jitter) && (vexRT[Ch4] > -jitter)){			//Rx
			Rx_controllerInput = 0;
		} else {
			Rx_controllerInput = abs(vexRT[Ch4]);
		}

		if ((vexRT[Ch3] < jitter) && (vexRT[Ch3] > -jitter)){			//Ry
			Ry_controllerInput = 0;
		} else {
			Ry_controllerInput = abs(vexRT[Ch3]);*/
