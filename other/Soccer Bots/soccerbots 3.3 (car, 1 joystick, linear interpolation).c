#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use car-style steering, where the right Y-axis		*|
|*	joystick controls the bot moving forward and backwards, and the			*|
|*	right X-axis joystick controls steering byslowing down the left or	*|
|*	right wheels respectively. The rear wheel is equal to the difference*|
|*	between the right and left motors, to help the bot pivot and remain	*|
|*	stable.																															*|
\*----------------------------------------------------------------------*/

const float rearMultiplier = 1; //This multiplier is used for the back wheel, to ensure that it is pivoting at a similar speed to the outside wheels.
const float jitter = 10;
const float motorMax = 127;
//const string leftRightCh = "Ch3";	//Ch3 is single joystick, only using left joystick. Ch1 is double joystick, with forward/backwards as left joystick and left/right as right joystick

float targetSpeedL = 0.0;
float targetSpeedR = 0.0;

float smoothSpeedL = 0.0;
float smoothSpeedR = 0.0;

float speedSmoothing = 0.001; //0<x<1, closer to zero = smoother

/*--Linear interpolation (smooth acceleration) function--*/
	float lerp(float a, float b, float weight)
	{
		//Linear interpolation formula: x = a(1-t) + bt
		return a*(1 - weight) + b*weight;
	}


task main()
{
	while(1==1)
	{
		//motor(rightMotor) = (vexRT[Ch3]) *;	//Ch3 (joystick Ry) moves the right wheels forward and backwards.
		//motor(leftMotor) = vexRT[Ch4];	//Ch4 (joystick Rx) moves the left 	wheels forward and backwards.

		//motor(rearMotor) = (vexRT[Ch3] - vexRT[Ch2]) * rearMultiplier;	//The rear motor is used to help with pivoting, given by the difference between the left and right inputs





			//Lx is Ch1, Ly is Ch2, Ry is Ch3, Rx is Ch4
  	  //If Lx [Ch1] is right, slow down right motor. If it's left, slow down left motor
			if ((vexRT[Ch4] <= -jitter) && ((vexRT[Ch3] <= jitter)&&(vexRT[Ch3] >= -jitter))) 					//All the way right, rotate clockwise
			{
				targetSpeedL = motorMax;
				targetSpeedR = -motorMax;
			}
			else if ((vexRT[Ch4] >= jitter) && ((vexRT[Ch3] <= jitter)&&(vexRT[Ch3] >= -jitter)))			//All the way left, rotate counter-clockwise
			{
				targetSpeedL = -motorMax;
				targetSpeedR = motorMax;
			}
			if (vexRT[Ch4] >= 0)					//Turn Clockwise, Right motor small multiplier
			{
				targetSpeedL = vexRT[Ch3];
				targetSpeedR = (vexRT[Ch3] * ((-2 * vexRT[Ch4]) + motorMax)/motorMax);
  		}
  		else if (vexRT[Ch4] < 0)					//Turn Counter-Clockwise, Left motor small multiplier
  		{
				targetSpeedL = (vexRT[Ch3] * ((2 * vexRT[Ch4]) + motorMax)/motorMax);
				targetSpeedR = vexRT[Ch3];
			}
			else
			{
				targetSpeedL = 0
				targetSpeedR = 0;
			}

			/*Smooth the speed to prevent ...motor damage?*/
			smoothSpeedL = lerp(smoothSpeedL, targetSpeedL, speedSmoothing);			//lerp(smoothSpeedL, targetSpeedL, accel * (delta));
			smoothSpeedR = lerp(smoothSpeedR, targetSpeedR, speedSmoothing);			//lerp(smoothSpeedR, targetSpeedR, accel * (delta));



			motor[leftMotor] = smoothSpeedL;
			motor[rightMotor] = smoothSpeedR;
			motor(rearMotor) = (smoothSpeedL - smoothSpeedR) * rearMultiplier;	//The rear motor is used to help with pivoting, given by the difference between the left and right inputs
	}
}






//SMOOTH ACCELERATION
	/*
	const bool smoothAcceleration = false;

	int time = 0;
	int timePrev = 0;
	float delta = 0;

	float accel = 0.006;

	float lerp(float begin, float end, float weight)
	{
		return begin + (end - begin) * weight;
	}

	*/

	/*
	void transition(float begin, float end, int transTime, bool left, bool right, bool revL, bool revR) //Time in millisecs?
{
	float speed = begin;
	int curTime = 0;
	while (abs(speed - end) > 2.0)
	{
		if (left == true)
		{
			if (revL == true)
			{
				motor[leftFrontMotor] = -speed;
			}
			else
			{
				motor[leftFrontMotor] = speed;
			}
		}
		if (right == true)
		{
			if (revR == true)
			{
				motor[rightFrontMotor] = -speed;
			}
			else
			{
				motor[rightFrontMotor] = speed;
			}
		}
		speed = lerp(begin, end, (curTime / transTime));
		curTime += 1;
	}

	if (left == true)
	{
		if (revL == true)
		{
			motor[leftFrontMotor] = -end;
		}
		else
		{
			motor[leftFrontMotor] = end;
		}
	}
	if (right == true)
	{
		if (revR == true)
		{
			motor[rightFrontMotor] = -end;
		}
		else
		{
			motor[rightFrontMotor] = end;
		}
	}

	return;
}

task main()
{
	while(1 == 1)
	{
		time = nSysTime;
		delta = time - timePrev; //delta = ms elapsed in loop
		*/
