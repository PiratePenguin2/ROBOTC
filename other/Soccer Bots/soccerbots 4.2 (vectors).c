#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use tank-style steering, where		*|
|*	the left and right joysticks control the left or right wheels on		*|
|*	the bot.
\*----------------------------------------------------------------------*/
//Config
	const float rearWheelMultiplier = 1;
	const float jitter = 15.0;
	const float maxSpeed = 62.5;


//Vars
	float rY; //Ch2
	float rX; //Ch1

	int rYtrig;
	int rXtrig;

	float botDrive;
	//float botPivot;

	float LtargetSpeed;
	float RtargetSpeed;

	float LsmoothSpeed;
	float RsmoothSpeed;


//Task Main--------------------------------------------------------------
task main()
{
	while (1==1)
	{
	//Update Joystick Forward/Backwards (Ch2)
		if ((vexRT[Ch2] < jitter) && (vexRT[Ch2] > -jitter))			//Rx
		{
			rY = 0;
			rYtrig = 0;
		}
		else if (vexRT[Ch2] <= -jitter)
		{
			rY = vexRT[Ch2];
			rYtrig = -1;
		}
		else	//vexRT[Ch2] >= jitter
		{
			rY = vexRT[Ch2];
			rYtrig = 1;
		}

	//Update Joystick Left/Right (Ch4)
		if ((vexRT[Ch1] < jitter) && (vexRT[Ch1] > -jitter))			//Rx
		{
			rX = 0;
			rYtrig = 0;
		}
		else if (vexRT[Ch1] <= -jitter)
		{
			rX = vexRT[Ch1];
			rXtrig = -1;
		}
		else	//vexRT[Ch1] >= jitter
		{
			rX = vexRT[Ch1];
			rXtrig = 1;
		}

//Bot drive speed
		botDrive = ((sqrt( (rX*rX) + (rY*rY) ) /127) * maxSpeed);		//a^2 + b^2 = c^2

//Bot pivot degree
		if (rX == 0)
		{
			rX = 0.1; 	//to avoid divide by 0
		}
		//botPivot = (atan(rY/rX));






/*Clean pivots*/
	//Full right
		else if (rXtrig == 1)
		{
			LtargetSpeed = botDrive;		//bot should pivot right
			RtargetSpeed = -botDrive;
		}

	//Full left
		else if (rXtrig == -1)
		{
			LtargetSpeed = -botDrive;	//bot should pivot left
			RtargetSpeed = botDrive;
		}

	//No rotation
		else if (rXtrig == 0)
		{
			LtargetSpeed = botDrive;		//bot shouldn't turn
			RtargetSpeed = botDrive;
		}

		else	//Will likely be removed
		{
			LtargetSpeed = 0;
			RtargetSpeed = 0;
		}


/*Could add smooth acceleration*/
		LsmoothSpeed = LtargetSpeed;
		RsmoothSpeed = RtargetSpeed;


	motor[leftMotor] = LtargetSpeed;		//REPLACE WITH smoothSpeed
	motor[rightMotor] = RtargetSpeed;
	motor[rearMotor] = ((LtargetSpeed - RtargetSpeed) * rearWheelMultiplier);


	//rX = 0;
	//rY = 0;
	//LtargetSpeed = 0;
	//RtargetSpeed = 0;
	//LsmoothSpeed = 0;
	//RsmoothSpeed = 0;

	rXtrig = 0;
	rYtrig = 0;


		//if degrees is in middle or on right side, left motor equals ("botDrive" / 127) times maxSpeed [number between 0 and 1, multiplied by maxspeed. if maxspeed is 100, then 0.9 drive *

	}
}
