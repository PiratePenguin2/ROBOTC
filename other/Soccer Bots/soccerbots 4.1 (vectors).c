#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use tank-style steering, where		*|
|*	the left and right joysticks control the left or right wheels on		*|
|*	the bot.
\*----------------------------------------------------------------------*/
//Config
	//const float rearWheelMultiplier = 1;
	const float jitter = 10.0;
	const float maxSpeed = 62.5;


//Vars
	float rY; //Ch3
	float rX; //Ch4

	int rYtrig;
	int rXtrig;

	float botDrive;
	float botPivot;

	float LtargetSpeed;
	float RtargetSpeed;



//Task Main
task main()
{
	while (1==1)
	{
	//Update Joystick Forward/Backwards (Ch3)
		if ((vexRT[Ch3] < jitter) && (vexRT[Ch3] > -jitter))			//Rx
		{
			rY = 0;
			rYtrig = 0;
		}
		else if (vexRT[Ch3] <= jitter)
		{
			rY = abs(vexRT[Ch3]);
			rYtrig = -1;
		}
		else
		{
			rY = abs(vexRT[Ch3]);
			rYtrig = 1;
		}

	//Update Joystick Left/Right (Ch4)
		if ((vexRT[Ch4] < jitter) && (vexRT[Ch4] > -jitter))			//Rx
		{
			rX = 0;
			rYtrig = 0;
		}
		else if (vexRT[Ch4] <= jitter)
		{
			rX = abs(vexRT[Ch4]);
			rXtrig = -1;
		}
		else
		{
			rX = abs(vexRT[Ch4]);
			rXtrig = 1;
		}

//Bot drive speed
		botDrive = ( ( sqrt((rX*rX)+(rY*rY)) /127) * maxSpeed);		//a^2 + b^2 = c^2

//Bot pivot degree
		if (rX == 0)
		{
			rX = 0.1; 	//to avoid divide by 0
		}
		botPivot = (atan(rY/rX));


/*Degree pivot*/
	//0 to 89.9, forward veer right
		if ((rYtrig == 1) && (rXtrig == 1))
		{
			botPivot = (90 - botPivot); //Flip to center with 0 going forward, Quadrent 1
			LtargetSpeed = botDrive;
			RtargetSpeed = botDrive;	//(rY * ((2 * rX) + maxSpeed)/maxSpeed)								//<----------------PICK UP HERE
		}

	//-0.1 to -89.9, forward veer left
		else if ((rYtrig == 1) && (rXtrig == -1))
		{
			botPivot = (botPivot - 90); //Subtract 90 to get to Quadrent 2
		}

	//-90.1 to -179.9, backward veer (left)
		else if ((rYtrig == -1) && (rXtrig == -1))
		{
			botPivot = (botPivot - 180); //Subtract 180 to get to Quadrent 3
		}

	//90.1 to 179.9, backward veer (left)
		else if ((rYtrig == -1) && (rXtrig == -1))
		{
			botPivot = (90 - botPivot) + 90; //Subtract 180 to get to Quadrent 3
		}


/*Clean pivots*/
	//Full right
		else if ((rYtrig == 0) && (rXtrig == 1))
		{
			LtargetSpeed = botDrive;		//bot should pivot right
			RtargetSpeed = botDrive;
		}

	//Full left
		else if((rYtrig == 0) && (rXtrig == -1))
		{
			LtargetSpeed = -botDrive;	//bot should pivot left
			RtargetSpeed = botDrive;
		}

	//No rotation
		else //(rXtrig == 0)
		{
			LtargetSpeed = botDrive;		//bot shouldn't turn
			RtargetSpeed = botDrive;
		}




		//if degrees is in middle or on right side, left motor equals ("botDrive" / 127) times maxSpeed [number between 0 and 1, multiplied by maxspeed. if maxspeed is 100, then 0.9 drive *

	}
}
