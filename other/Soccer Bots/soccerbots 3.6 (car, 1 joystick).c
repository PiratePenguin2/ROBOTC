#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rearMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------*\
|*	This is the code for the soccer bots, which have 2 omni wheels on		*|
|*	each side (each set linked to a single motor) and 1 on the back for *|
|*	steering, totaling 5.																								*|
|*																																			*|
|*	This program will use car-style steering, where the right Y-axis		*|
|*	joystick controls the bot moving forward and backwards, and the			*|
|*	right X-axis joystick controls steering byslowing down the left or	*|
|*	right wheels respectively. The rear wheel is equal to the difference*|
|*	between the right and left motors, to help the bot pivot and remain	*|
|*	stable.																															*|
\*----------------------------------------------------------------------*/

/*-----Config-----*/
	const float rearMultiplier = 1; //This multiplier is used for the back wheel, to ensure that it is pivoting at a similar speed to the outside wheels.
	const float jitter = 70.0;
	const float motorMax = 80.0; // # out of 127
	const float speedSmoothing = 0.001; //0<x<1, closer to zero = smoother
	const float motorMin = 10.0;
		//const string leftRightCh = "Ch3";	//Ch3 is single joystick, only using left joystick. Ch1 is double joystick, with forward/backwards as left joystick and left/right as right joystick

//Variables
	float targetSpeedL = 0.0;
	float targetSpeedR = 0.0;

	float smoothSpeedL = 0.0;
	float smoothSpeedR = 0.0;





/*--Linear interpolation (smooth acceleration) function--*/
	float lerp(float a, float b, float weight)
	{
		//Linear interpolation formula: x = a(1-t) + bt
		return a*(1 - weight) + b*weight;
	}



/*-----Task Main-----*/
task main()
{
	while(1==1)
	{
			//Lx is Ch1, Ly is Ch2, Ry is Ch3, Rx is Ch4
  	  //If Lx [Ch4] is right, slow down right motor. If it's left, slow down left motor

	/*Take inputs from the joystick, and determine how the bot should move*/
		//Pivot
			if ((vexRT[Ch4] <= -jitter) && ((vexRT[Ch3] <= jitter)&&(vexRT[Ch3] >= -jitter))) 					//All the way right, rotate clockwise
			{
				targetSpeedL = -vexRT[Ch4];
				targetSpeedR = vexRT[Ch4];
			}
			else if ((vexRT[Ch4] >= jitter) && ((vexRT[Ch3] <= jitter)&&(vexRT[Ch3] >= -jitter)))			//All the way left, rotate counter-clockwise
			{
				targetSpeedL = vexRT[Ch4];
				targetSpeedR = -vexRT[Ch4];
			}
		//Forwards
			else if ((vexRT[Ch4] >= jitter) && (vexRT[Ch3] >= jitter || vexRT[Ch3] <= jitter))					//Turn Clockwise, Right motor small multiplier
			{
				targetSpeedL = vexRT[Ch3];
				targetSpeedR = (vexRT[Ch3] * ((-2 * vexRT[Ch4]) + 127) / 127);
  		}
  		else if ((vexRT[Ch4] <= jitter) && (vexRT[Ch3] >= jitter || vexRT[Ch3] <= jitter))					//Turn Counter-Clockwise, Left motor small multiplier
  		{
				targetSpeedL = (vexRT[Ch3] * ((2 * vexRT[Ch4]) + 127) / 127);
				targetSpeedR = vexRT[Ch3];
			}
		//Backwards
			/*
			else if ((vexRT[Ch4] >= jitter) && (vexRT[Ch3] <= -jitter))					//Turn Counter-Clockwise, Left motor small multiplier
			{
				targetSpeedL = (vexRT[Ch3] * ((2 * vexRT[Ch4]) + 127) / 127); /////////////PROBLEM!!!!! uh oh!!!
				targetSpeedR = -vexRT[Ch3];
  		}
  		else if ((vexRT[Ch4] <= jitter) && (vexRT[Ch3] <= -jitter))					//Turn Clockwise, Right motor small multiplier
  		{
				targetSpeedL = -vexRT[Ch3];
				targetSpeedR = (vexRT[Ch3] * ((-2 * vexRT[Ch4]) + 127) / 127); ////////////////
			}
			*/
		//Straight for/backward /*----------------------EXPERIMENTAL------------------------*/
			else if (vexRT[Ch3] >= jitter || vexRT[Ch3] <= jitter)
			{
				targetSpeedL = vexRT[Ch3];
				targetSpeedR = vexRT[Ch3];
			}

		//Stop
			else
			{
				targetSpeedL = 0;
				targetSpeedR = 0;
			}

		targetSpeedL = (targetSpeedL / 127) * motorMax;
		targetSpeedR = (targetSpeedR / 127) * motorMax;


	/*Smooth the speed to prevent motor damage*/
			smoothSpeedL = lerp(smoothSpeedL, targetSpeedL, speedSmoothing);			//lerp(smoothSpeedL, targetSpeedL, accel * (delta));
			smoothSpeedR = lerp(smoothSpeedR, targetSpeedR, speedSmoothing);			//lerp(smoothSpeedR, targetSpeedR, accel * (delta));


	/*Write the new speeds to the Left, Right, and Rear motors*/
			if( abs(smoothSpeedL) > motorMin)
			{
				motor[leftMotor] = smoothSpeedL;
			}
			else motor[leftMotor] = 0.0;
			if (abs(smoothSpeedR) > motorMin)
			{
				motor[rightMotor] = smoothSpeedR;
			}
			else motor[rightMotor] = 0.0;
			motor(rearMotor) = (smoothSpeedL - smoothSpeedR) * rearMultiplier;	//The rear motor is used to help with pivoting, given by the difference between the left and right inputs
	}
}
		// robot :)
		// -approved by the Club Secretary of War
