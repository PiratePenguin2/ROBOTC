#pragma config(Sensor, dgtl2,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ,               sensorQuadEncoder)
#pragma config(Motor,  port1,           leftPivot,     tmotorVex393_HBridge, openLoop, encoderPort, None)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightPivot,    tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------------------------*\
This code is for a 2 caster wheel swerve robot, which means the bot will have two motorized castor wheels
that can both pivot and drive independent of each other.

This allows the bot to rotate and move laterally in all directions simultaneously, with the left joystick controlling
the bot's rotation and the right joystick controlling lateral movement.

These inputs are added together for each pivot and drive motor using vector addition, provinding a direction (rotation)
and magnitude (speed) for each wheel assembly.
\*----------------------------------------------------------------------------------------------------------------------*/




/*----------------------------------------------------------------------------------------------------------------------*\
Movement of the motors will be accomplished by internally keeping track of the bot's rough rotation relative to the
zero degrees it is to be reset to each competition (by button push). This could also be accomplished through sensors by
dangling high grip tires or treads underneath the bot that wouldn't rotate along with the bot, allowing an encoder to
record the bot's rotation/speed relative to the non-pivoting treads. In addition, each pivot and drive motor is tracked with
encoders, allowing the bot to compare the current rotation/speed to the intended rotation/speed to obey the controller
instructions.

In other words, the controller will give instructions on where the bot should move and how fast, and the rotation the bot
should be targeting, and the code will translate this information to ideal speeds and target rotations for each motor at
each point in time. The bot will then compare this to the overall bot's rotation/speed, as well as the rotation/speed of
each motor, and adjust their speeds to match their ideal speeds and target positions.
\*----------------------------------------------------------------------------------------------------------------------*/


	const float jitterRange = 5;

	void controllerInput(short channel, short directionID);		//[Base] Updates "ideal" positions based on the controller inputs using vector addition
	void botIdealPivotFn();

//----------Inputs----------
/* The inputs from the controller */
	float Lx_controllerInput;
	float Ly_controllerInput;

	float Rx_controllerInput;
	float Ry_controllerInput;

/* The rough speed and rotation of the entire bot */
//	float botPos_pivot; //maybe add an encoder or use existing encoder that understands where pivots start at
//	float botPos_drive;

/* The speeds at which each motor is actively traveling (encoders)*/
	float Lpos_pivot = 0.0;
	float Lpos_drive = 0.0;

	float Fpos_pivot = 0.0;
	float Fpos_drive = 0.0;

	float Rpos_pivot = 0.0;
	float Rpos_drive = 0.0;



//----------Ideal Speeds----------
/* The ideal direction and speed of the entire bot */
	float botIdeal_pivot = 0.0; //For all "pivot", in Degrees
	float botIdeal_drive = 0.0; //For all "drive", meters per second or percent speed?? "+" is drive forward (most likely), "-" is drive backwards


/* The ideal directions and speeds of each wheel assembly */
	float LIdeal_pivot = 0.0;
	float LIdeal_drive = 0.0;

	float FIdeal_pivot = 0.0;
	float FIdeal_drive = 0.0;

	float RIdeal_pivot = 0.0;
	float RIdeal_drive = 0.0;




/* The rotation the bot and each pivot should physically be at (using encoders)*/


	//int botPos_pivot = 0.0; 	//maybe add an encoder or use existing encoder that understands where pivots start at
	//int bot = 0.0;








task main()
{
	while(1==1){
			//Lx is Ch1, Ly is Ch2, Ry is Ch3, Rx is Ch4
			//vexRT[Ch1]


	/* [Base] Update "ideal" positions based on the controller inputs using vector addition */
		//drive
		controllerInput(Ch4,Rx_controllerInput);
		controllerInput(Ch3,Ry_controllerInput);

		writeDebugStreamLine("%c", Rx_controllerInput);
		writeDebugStreamLine("%c", Ry_controllerInput);
//		botIdeal_drive = sqrt( (Rx_controllerInput^2)+(Ry_controllerInput^2) );		//a^2 + b^2 = c^2


		//pivot
		controllerInput(Ch1,Lx_controllerInput);
		controllerInput(Ch2,Ly_controllerInput);

		botIdealPivotFn();


		/* [Base] Understand how the bot has moved since the last tick and update the smooth path to an existing or new ideal*/




		/* [All] Execute new instructions to motors */
//		motor(leftPivot) = Lpos_pivot;
//		motor(leftDrive) = Rpos_drive;

//		motor(frontPivot) = Fpos_pivot;
//		motor(frontDrive) = Fpos_drive;

//		motor(rightPivot) = Lpos_pivot;
//		motor(rightDrive) = Rpos_drive;

	}
}



/*****************FUNCTIONS********************************/
void controllerInput(short channel, short directionID)
{
	if ((vexRT[channel] < jitterRange) && (vexRT[channel] > -jitterRange))			//Rx
		{
			directionID = 0;

		}
		else
		{
			directionID = abs(vexRT[channel]);
		}
}



void botIdealPivotFn()
{
	if ((Lx_controllerInput >= 0) && (Ly_controllerInput <= 90))
		{
			//0 to 90
		}
		else if ((Lx_controllerInput > 90) && (Ly_controllerInput <= 180))
		{
			//90.1 to 180
		}
		else if ((Lx_controllerInput < 0) && (Ly_controllerInput >= -90))
		{
			//-0.1 to -90
		}
		else
		{
			//-90.1 to -179.9
		}
}





















		/*if ((vexRT[Ch4] < jitterRange) && (vexRT[Ch4] > -jitterRange)){			//Rx
			Rx_controllerInput = 0;
		} else {
			Rx_controllerInput = abs(vexRT[Ch4]);
		}

		if ((vexRT[Ch3] < jitterRange) && (vexRT[Ch3] > -jitterRange)){			//Ry
			Ry_controllerInput = 0;
		} else {
			Ry_controllerInput = abs(vexRT[Ch3]);*/
