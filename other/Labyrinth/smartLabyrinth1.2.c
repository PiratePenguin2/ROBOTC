#pragma config(Sensor, dgtl9,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, PIDControl, encoderPort, dgtl9)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, PIDControl, reversed, encoderPort, dgtl11)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------*\
|*						Config						*|
\*------------------------------*/
	const int tol = 5;
	const int encoderTicks = 360;
		//const int fullSpeed = 127;

	const float wheelDiam = 4; // Diameter of the wheel in inches
	const float botWidth = 12;
		//const float pivotXOffset = 0;


/*------------------------------*\
|*						 Setup						*|
\*------------------------------*/
	const float wheelCirc = wheelDiam * PI;

	void StopMotors()
	{
		motor[leftMotor] = 0;
		motor[rightMotor] = 0;
	}

	void ResetEncoders()
	{
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
	}


/*------------------------------*\
|*					MoveInches					*|
\*------------------------------*/
void MoveInches(float travel, float maxSpeed)
{
	ResetEncoders();
	int ticks = (travel / wheelCirc) * (encoderTicks); //The number of encoder ticks it will take to go travel inches
	//stall = "";

	while (abs(SensorValue[leftEncoder] - ticks) > tol && abs(SensorValue[rightEncoder] - ticks) > tol)
	{
		if ( abs(SensorValue[leftEncoder] - ticks) >= tol)
		{
			motor[leftMotor] = SensorValue[leftEncoder] < ticks ? maxSpeed : -maxSpeed;	//Left motor
		}

		if ( abs(SensorValue[rightEncoder] - ticks) >= tol)
		{
			motor[rightMotor] = SensorValue[rightEncoder] < ticks ? maxSpeed : -maxSpeed;	//Right motor
		}

		/*if ( abs(SensorValue[leftEncoder] - SensorValue[rightEncoder]) <= 2 encoderTicks)
		{
			stall
		}*/
	} //While

	StopMotors();
}	//Turn Degrees



/*------------------------------*\
|*					TurnDegrees					*|
\*------------------------------*/
void TurnDegrees(float turnRad, float deg, float maxSpeed)
{
	ResetEncoders();
	int ticksL = ((turnRad + (botWidth/2)) * PI) * (deg / 360) * (1 / wheelCirc) * encoderTicks; //TurnCircumference L+ * % of TurnCircumference * distance per wheel rotation
	int ticksR = ((turnRad - (botWidth/2)) * PI) * (deg / 360) * (1 / wheelCirc) * encoderTicks; //TurnCircumference R- * % of TurnCircumference * distance per wheel rotation

	//int ticksL = deg >= 0 ? 720 : -720; //Compute the number of encoder ticks to make the turn
	//int ticksR = deg >= 0 ? -720 : 720;

	while (abs(SensorValue[leftEncoder] - ticksL) > tol && abs(SensorValue[rightEncoder] - ticksR) > tol)
	{
		if ( abs(SensorValue[leftEncoder] - ticksL) >= tol)
		{
			if (ticksL >= 0)
				motor[leftMotor] = SensorValue[leftEncoder] >  ticksL ? maxSpeed : -maxSpeed; //Left Motor
			else
				motor[leftMotor] = SensorValue[leftEncoder] <  ticksL ? maxSpeed : -maxSpeed; //Left Motor
		}

		if ( abs(SensorValue[rightEncoder] - ticksR) >= tol)
		{
			if (ticksR >= 0)
				motor[rightMotor] = SensorValue[rightEncoder] >  ticksR ? maxSpeed : -maxSpeed; //Right Motor
			else
				motor[rightMotor] = SensorValue[rightEncoder] <  ticksR ? maxSpeed : -maxSpeed; //Right Motor
		}


	} //While

	StopMotors();
} //TurnDegrees








/*------------------------------*\
|*					 TaskMain						*|
\*------------------------------*/
task main()
{
  while (true)
  {
   //Test Move Forward/Backwards
  	if (vexRT[Btn7U] == 1)
    {
			MoveInches(24, 10);	//float travel (inches), float maxSpeed (-127 to 127)
			wait1Msec(1000);
			MoveInches(-24, 10);	//float travel (inches), float maxSpeed (-127 to 127)
			wait1Msec(1000);
		}

	//Test Pivot 90/-90
		if (vexRT[Btn8U] == 1)
		{
			TurnDegrees(10, 90, 10); //float turnRad, float deg, float maxSpeed
			wait1Msec(1000);
			TurnDegrees(10, -90, 10); //float turnRad, float deg, float maxSpeed
			wait1Msec(1000);
		}


	} //While
} //Main
